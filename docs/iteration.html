

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Iterative Methods &mdash; cxroots 3.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=dd1205ac"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Rootfinding Result" href="result.html" />
    <link rel="prev" title="Symmetric Bilinear Form" href="prod.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            cxroots
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="theory.html">Theory</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="countroots.html">Counting Roots</a></li>
<li class="toctree-l1"><a class="reference internal" href="demo.html">Demonstrating Rootfinding</a></li>
<li class="toctree-l1"><a class="reference internal" href="guesses.html">Using Known Roots or Symmetries</a></li>
<li class="toctree-l1"><a class="reference internal" href="logging.html">Viewing Progress</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="ex_annular_combustion.html">Stability of an Annular Combustion Chamber</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="paths.html">Paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="contours.html">Contours</a></li>
<li class="toctree-l1"><a class="reference internal" href="prod.html">Symmetric Bilinear Form</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Iterative Methods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#cxroots.iterative_methods.iterate_to_root"><code class="docutils literal notranslate"><span class="pre">iterate_to_root()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#cxroots.iterative_methods.muller"><code class="docutils literal notranslate"><span class="pre">muller()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#cxroots.iterative_methods.newton"><code class="docutils literal notranslate"><span class="pre">newton()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="result.html">Rootfinding Result</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">cxroots</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Iterative Methods</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/iteration.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="iterative-methods">
<h1>Iterative Methods<a class="headerlink" href="#iterative-methods" title="Link to this heading"></a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="cxroots.iterative_methods.iterate_to_root">
<span class="sig-prename descclassname"><span class="pre">cxroots.iterative_methods.</span></span><span class="sig-name descname"><span class="pre">iterate_to_root</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">complex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">complex</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">complex</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refine_roots_beyond_tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">complex</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">complex</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">complex</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="reference internal" href="_modules/cxroots/iterative_methods.html#iterate_to_root"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cxroots.iterative_methods.iterate_to_root" title="Link to this definition"></a></dt>
<dd><p>Starting with initial point x0 iterate to a root of f. This function is called
during the rootfinding process to refine any roots found. If df is given then
the Newton-Raphson method, <a class="reference internal" href="#cxroots.iterative_methods.newton" title="cxroots.iterative_methods.newton"><code class="xref py py-func docutils literal notranslate"><span class="pre">newton()</span></code></a>, will be used,
otherwise Muller’s method, <a class="reference internal" href="#cxroots.iterative_methods.muller" title="cxroots.iterative_methods.muller"><code class="xref py py-func docutils literal notranslate"><span class="pre">muller()</span></code></a>, will be used
instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<em>complex</em>) – An initial point for the iteration.</p></li>
<li><p><strong>f</strong> (<em>function</em>) – Function of a single variable which we seek to find a root of.</p></li>
<li><p><strong>df</strong> (<em>function</em><em>, </em><em>optional</em>) – The derivative of f.</p></li>
<li><p><strong>step_tol</strong> (<em>float</em><em>, </em><em>optional</em>) – The routine ends if the step size, dx, between sucessive
iterations satisfies abs(dx) &lt; step_tol and refine_roots_beyond_tol is False.</p></li>
<li><p><strong>root_tol</strong> (<em>float</em><em>, </em><em>optional</em>) – A root, x, is only returned if abs(f(x)) &lt; root_tol, otherwise None is returned</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – The routine ends after max_iter iterations.</p></li>
<li><p><strong>refine_roots_beyond_tol</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True then the routine ends only once the error of the previous iteration,
x0, was at least as good as the current iteration, x, in the sense that
abs(f(x)) &gt;= abs(f(x0)), and the previous iteration satisfied
abs(dx0) &lt; step_tol. In this case the previous iteration is returned as the
approximation of the root, provided that it satisfies abs(f(x)) &lt; root_tol</p></li>
<li><p><strong>callback</strong> (<em>function</em><em>, </em><em>optional</em>) – After each iteration callback(x, dx, f(x), iteration) will be
called where ‘x’ is the current iteration of the estimated root,
‘dx’ is the step size between the previous and current ‘x’ and
‘iteration’ the number of iterations that have been taken.  If
the callback function evaluates to True then the routine will end.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An approximation for a root of f. If the rootfinding was
unsucessful then None will be returned instead.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>complex</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cxroots.iterative_methods.muller">
<span class="sig-prename descclassname"><span class="pre">cxroots.iterative_methods.</span></span><span class="sig-name descname"><span class="pre">muller</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">complex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">complex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x3</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">complex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">complex</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refine_roots_beyond_tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">complex</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">complex</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">complex</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">complex</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/cxroots/iterative_methods.html#muller"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cxroots.iterative_methods.muller" title="Link to this definition"></a></dt>
<dd><p>A wrapper for mpmath’s implementation of Muller’s method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x1</strong> (<em>float</em><em> or </em><em>complex</em>) – An initial point for iteration, should be close to a root of f.</p></li>
<li><p><strong>x2</strong> (<em>float</em><em> or </em><em>complex</em>) – An initial point for iteration, should be close to a root of f.
Should not equal x1.</p></li>
<li><p><strong>x3</strong> (<em>float</em><em> or </em><em>complex</em>) – An initial point for iteration, should be close to a root of f.
Should not equal x1 or x2.</p></li>
<li><p><strong>f</strong> (<em>function</em>) – Function of a single variable which we seek to find a root of.</p></li>
<li><p><strong>step_tol</strong> (<em>float</em><em>, </em><em>optional</em>) – The routine ends if the step size, dx, between sucessive
iterations satisfies abs(dx) &lt; step_tol and refine_roots_beyond_tol is False.</p></li>
<li><p><strong>root_tol</strong> (<em>float</em><em>, </em><em>optional</em>) – The routine ends if abs(f(x)) &lt; root_tol and refine_roots_beyond_tol is False.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – The routine ends after max_iter iterations.</p></li>
<li><p><strong>refine_roots_beyond_tol</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True then routine ends if the error of the previous iteration,
x0, was at least as good as the current iteration, x, in the
sense that abs(f(x)) &gt;= abs(f(x0)) and the previous iteration
satisfied either abs(dx0) &lt; step_tol or abs(f(x0)) &lt; root_tol.  In
this case the previous iteration is returned as the approximation
of the root.</p></li>
<li><p><strong>callback</strong> (<em>function</em><em>, </em><em>optional</em>) – After each iteration callback(x, dx, f(x), iteration) will be
called where ‘x’ is the current iteration of the estimated root,
‘dx’ is the step size between the previous and current ‘x’ and
‘iteration’ the number of iterations that have been taken.  If
the callback function evaluates to True then the routine will end.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>complex</em> – The approximation to a root of f.</p></li>
<li><p><em>float</em> – abs(f(x)) where x is the final approximation for the root of f.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cxroots.iterative_methods.newton">
<span class="sig-prename descclassname"><span class="pre">cxroots.iterative_methods.</span></span><span class="sig-name descname"><span class="pre">newton</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">complex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">complex</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">complex</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">complex</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refine_roots_beyond_tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">complex</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">complex</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">complex</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">complex</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/cxroots/iterative_methods.html#newton"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cxroots.iterative_methods.newton" title="Link to this definition"></a></dt>
<dd><p>Find an approximation to a point xf such that f(xf)=0 for a
scalar function f using Newton-Raphson iteration starting at
the point x0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<em>float</em><em> or </em><em>complex</em>) – Initial point for Newton iteration, should be as close as
possible to a root of f</p></li>
<li><p><strong>f</strong> (<em>function</em>) – Function of a single variable which we seek to find a root of.</p></li>
<li><p><strong>df</strong> (<em>function</em>) – Function of a single variable, df(x), providing the
derivative of the function f(x) at the point x</p></li>
<li><p><strong>step_tol</strong> (<em>float</em><em>, </em><em>optional</em>) – The routine ends if the step size, dx, between sucessive
iterations satisfies abs(dx) &lt; step_tol and refine_roots_beyond_tol is False.</p></li>
<li><p><strong>root_tol</strong> (<em>float</em><em>, </em><em>optional</em>) – The routine ends if abs(f(x)) &lt; root_tol and refine_roots_beyond_tol is False.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – The routine ends after max_iter iterations.</p></li>
<li><p><strong>refine_roots_beyond_tol</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True then routine ends if the error of the previous iteration,
x0, was at least as good as the current iteration, x, in the
sense that abs(f(x)) &gt;= abs(f(x0)) and the previous iteration
satisfied either abs(dx0) &lt; step_tol or abs(f(x0)) &lt; root_tol.  In
this case the previous iteration is returned as the approximation
of the root.</p></li>
<li><p><strong>callback</strong> (<em>function</em><em>, </em><em>optional</em>) – After each iteration callback(x, dx, f(x), iteration) will be
called where ‘x’ is the current iteration of the estimated root,
‘dx’ is the step size between the previous and current ‘x’ and
‘iteration’ the number of iterations that have been taken.  If
the callback function evaluates to True then the routine will end.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>complex</em> – The approximation to a root of f.</p></li>
<li><p><em>float</em> – abs(f(x)) where x is the final approximation for the root of f.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="prod.html" class="btn btn-neutral float-left" title="Symmetric Bilinear Form" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="result.html" class="btn btn-neutral float-right" title="Rootfinding Result" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017, Robert Parini.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>